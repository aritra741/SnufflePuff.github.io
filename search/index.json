[{"content":"String related problems used to scare the shit out of me. Then I was introduced to some string suffix structures and it absolutely blew my mind. I don't claim to be an expert on suffix structures, but I hope my approach to solve the following problems will help you get some insight.\nPlease keep in mind that this article is in no way an introduction to these data structures. I'll attach some links at the end. Read them to understand how these data structures work.\nLet's start then.\n1. Codeforces GYM 101991E- Exciting Menus Problem statement:\n\rProblem Statement\r\nProblem link: Exciting Menus - Codeforces\nLet's think about the popularity of a substring first. If this was the only thing that we were asked to find, then a trie would suffice. Length of the prefix is also easy to maintain in a trie. The only thing remaining is the joy level.\nIt's pretty apparent that if we have multiple occurrences of a substring, then we should take the highest joy level corresponding to that substring. I don't think we can do that with a normal trie. Here's where Aho-Corasick comes into play.\nThink what the fail link of an Aho-Corasick node means. It points to the node with the maximum prefix match with the suffix of the original node. Suppose we have a prefix \u0026quot;aab\u0026quot;. Then the node corresponding to this prefix must be a fail link/suffix link to a prefix ending with \u0026quot;aab\u0026quot;, right? Then that node will be a suffix link to another node ending with \u0026quot;aab\u0026quot; and so on.\nNow, we will make another graph where we will add a directed edge from the suffix link node to the original node. For example, if the suffix link of a prefix \u0026quot;bccaab\u0026quot; goes to the prefix \u0026quot;aab\u0026quot;, then we will add a directed edge from \u0026quot;aab\u0026quot; to \u0026quot;bccaab\u0026quot;. This graph will be a rooted tree. In this newly formed graph, the descendants of \u0026quot;aab\u0026quot; will be the prefixes which have \u0026quot;aab\u0026quot; as their suffix. So, if we know the maximum joy level of the descendants of \u0026quot;aab\u0026quot;, we can assign that value to \u0026quot;aab\u0026quot;; pretty cool right?\nNow, we'll just traverse each node of the Aho-Corasick automaton and use the formula on each of them to find out the answer.\nHere's my code:\n#include \u0026lt;bits/stdc++.h\u0026gt;#define N 100007 #define ll long long #define pii pair\u0026lt;int,int\u0026gt; #define ff first #define ss second using namespace std; std::vector\u0026lt;int\u0026gt; adj[N]; string s[N]; int node[N][27]; int vis[N]; int val[N]; int backnode[N]; int cnt[N]; bool ending[N]; int id; int ln[N]; int arr[N]; ll ans; int depth[N]; inline void init() { id = 0; for (int i = 0; i \u0026lt; 26; i++) node[id][i] = 0; } inline int newnode() { id++; for (int i = 0; i \u0026lt; 26; i++) { node[id][i] = 0; } backnode[id] = 0; cnt[id] = 0; val[id] = 0; ending[id] = 0; depth[id] = 0; return id; } inline void Insert(string \u0026amp;st) { int u = 0; int n = st.size(); for (int i = 0; i \u0026lt; n; i++) { int x = st[i] - \u0026#39;a\u0026#39;; if (!node[u][x]) node[u][x] = newnode(); u = node[u][x]; val[u] = max(val[u], arr[i]); cnt[u]++; depth[u] = i + 1; } ending[u] = 1; } inline void AhoCorasik() { queue\u0026lt;int\u0026gt;q; for (int i = 0; i \u0026lt; 26; i++) { if (node[0][i]) { q.push(node[0][i]); backnode[node[0][i]] = 0; } } while (!q.empty()) { int u = q.front(); int w = backnode[u]; adj[w].push_back(u); q.pop(); for (int i = 0; i \u0026lt; 26; i++) { int v = node[u][i]; if (v) { q.push(v); backnode[v] = node[backnode[u]][i]; } else { node[u][i] = node[backnode[u]][i]; } } } } void dfs(int x) { ans = max( ans, 1LL * depth[x] * val[x] * cnt[x] ); for ( auto v : adj[x] ) { dfs(v); } } int traverse(int x) { for ( auto v : adj[x] ) { val[x] = max(val[x], traverse(v)); } return val[x]; } int main() { ios_base::sync_with_stdio(0); cin.tie(0); freopen(\u0026#34;exciting.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); int tc; cin \u0026gt;\u0026gt; tc; while (tc--) { init(); ans = 0; int n; cin \u0026gt;\u0026gt; n; for ( int i = 0; i \u0026lt; n; i++ ) { cin \u0026gt;\u0026gt; s[i]; ln[i] = s[i].size(); } for ( int i = 0; i \u0026lt; n; i++ ) { for ( int j = 0; j \u0026lt; ln[i]; j++ ) cin \u0026gt;\u0026gt; arr[j]; Insert(s[i]); } AhoCorasik(); int k = traverse(0); dfs( 0 ); for( int i=0;i\u0026lt;=id;i++ ) adj[i].clear(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } ","date":"2021-07-21T00:25:58+06:00","image":"/pexels-fiona-art-5186869.jpg","permalink":"/p/string-series-part-1/","title":"String series: Part 1"}]