[{"content":"String related problems used to scare the shit out of me. Then I was introduced to some string suffix structures and it absolutely blew my mind. I don't claim to be an expert on suffix structures, but I hope my approach to solve the following problems will help you get some insight.\nPlease keep in mind that this article is in no way an introduction to these data structures. I'll attach some links at the end. Read them to understand how these data structures work.\nLet's start then.\nCodeforces GYM 101991E- Exciting Menus Problem statement:\n\rProblem Statement\r\nProblem link: Exciting Menus - Codeforces\nLet's think about the popularity of a substring first. If this was the only thing that we were asked to find, then a trie would suffice. Length of the prefix is also easy to maintain in a trie. The only thing remaining is the joy level.\nIt's pretty apparent that if we have multiple occurrences of a substring, then we should take the highest joy level corresponding to that substring. I don't think we can do that with a normal trie. Here's where Aho-Corasick comes into play.\nThink what the fail link of an Aho-Corasick node means. It points to the node with the maximum prefix match with the suffix of the original node. Suppose we have a prefix ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ . Then the node corresponding to this prefix must be a fail link/suffix link to a prefix ending with ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ , right? Then that node will be a suffix link to another node ending with ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ and so on.\nNow, we will make another graph where we will add a directed edge from the suffix link node to the original node. For example, if the suffix link of a prefix ${\\text{\\textquoteleft} bccab \\text{\\textquoteright}}$ goes to the prefix ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$, then we will add a directed edge from ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ to ${\\text{\\textquoteleft} bccab \\text{\\textquoteright}}$. This graph will be a rooted tree. In this newly formed graph, the descendants of ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ will be the prefixes which have ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ as their suffix. So, if we know the maximum joy level of the descendants of ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$, we can assign that value to ${\\text{\\textquoteleft} aab \\text{\\textquoteright}}$ , pretty cool right?\nNow, we'll just traverse through each node of the Aho-Corasick automaton and use the formula on each of them to find out the answer.\nHere's my code:\n#include \u0026lt;bits/stdc++.h\u0026gt;#define N 100007 #define ll long long #define pii pair\u0026lt;int,int\u0026gt; #define ff first #define ss second using namespace std; std::vector\u0026lt;int\u0026gt; adj[N]; string s[N]; int node[N][27]; int vis[N]; int val[N]; int backnode[N]; int cnt[N]; bool ending[N]; int id; int ln[N]; int arr[N]; ll ans; int depth[N]; inline void init() { id = 0; for (int i = 0; i \u0026lt; 26; i++) node[id][i] = 0; } inline int newnode() { id++; for (int i = 0; i \u0026lt; 26; i++) { node[id][i] = 0; } backnode[id] = 0; cnt[id] = 0; val[id] = 0; ending[id] = 0; depth[id] = 0; return id; } inline void Insert(string \u0026amp;st) { int u = 0; int n = st.size(); for (int i = 0; i \u0026lt; n; i++) { int x = st[i] - \u0026#39;a\u0026#39;; if (!node[u][x]) node[u][x] = newnode(); u = node[u][x]; val[u] = max(val[u], arr[i]); cnt[u]++; depth[u] = i + 1; } ending[u] = 1; } inline void AhoCorasik() { queue\u0026lt;int\u0026gt;q; for (int i = 0; i \u0026lt; 26; i++) { if (node[0][i]) { q.push(node[0][i]); backnode[node[0][i]] = 0; } } while (!q.empty()) { int u = q.front(); int w = backnode[u]; adj[w].push_back(u); q.pop(); for (int i = 0; i \u0026lt; 26; i++) { int v = node[u][i]; if (v) { q.push(v); backnode[v] = node[backnode[u]][i]; } else { node[u][i] = node[backnode[u]][i]; } } } } void dfs(int x) { ans = max( ans, 1LL * depth[x] * val[x] * cnt[x] ); for ( auto v : adj[x] ) { dfs(v); } } int traverse(int x) { for ( auto v : adj[x] ) { val[x] = max(val[x], traverse(v)); } return val[x]; } int main() { ios_base::sync_with_stdio(0); cin.tie(0); freopen(\u0026#34;exciting.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); int tc; cin \u0026gt;\u0026gt; tc; while (tc--) { init(); ans = 0; int n; cin \u0026gt;\u0026gt; n; for ( int i = 0; i \u0026lt; n; i++ ) { cin \u0026gt;\u0026gt; s[i]; ln[i] = s[i].size(); } for ( int i = 0; i \u0026lt; n; i++ ) { for ( int j = 0; j \u0026lt; ln[i]; j++ ) cin \u0026gt;\u0026gt; arr[j]; Insert(s[i]); } AhoCorasik(); int k = traverse(0); dfs( 0 ); for( int i=0;i\u0026lt;=id;i++ ) adj[i].clear(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } Codeforces 1202E- You Are Given Some Strings\u0026hellip; Problem statement: \rProblem Statement\r\nProblem link: Problem - E - Codeforces\nSince the constraints are in the ${ \\ 2.10^5 }$ ballpark, we can't even dare to think of bruteforce here. Even though the problem deals with string concatenation, we'll now see why we don't need to concatenate anything.\nLet, $ {f(i)= \\mathrm{Number \\thinspace of \\thinspace query \\thinspace strings \\thinspace \\bm{starting} \\thinspace at \\thinspace position \\thinspace \\bm{i}} } $\n$ {g(i)= \\mathrm{Number \\thinspace of \\thinspace query \\thinspace strings \\thinspace \\bm{ending} \\thinspace at \\thinspace position \\thinspace \\bm{i}} } $\nThen the answer is ${\\displaystyle\\sum_{i=1}^n f(i).g(i) }$\nNow, our next challenge is to figure out how we can calculate ${f(i)}$ and ${g(i)}$.\nLet's have a look at ${f(i)}$ first. We can define ${f(i)}$ like this as well:\n${f(i)= \\mathrm{Number \\thickspace of \\thickspace query \\thickspace strings \\thickspace that \\thickspace are \\thickspace prefixes \\thickspace of \\thickspace the \\thickspace suffix \\thickspace starting \\thickspace at \\thickspace position \\thickspace \\bm{i} }}$\nWe can find out the number of times a prefix of a suffix repeats in a string using suffix array. Since suffix array is always sorted, the occurrence of any prefix in a suffix will always be consecutive. So let's build a suffix array using the string t. Now for every query string, we can find out how many times it has occurred in string t using binary search. We will get a range in the suffix array where the string sj occurs. We'll then increment the counter for each position in the range. That's it! We're done with ${f(i)}$.\nNow getting back to ${g(i)}$, we can observe that this is exactly ${f(i)}$ for the reversed version of the string t! To calculate ${g(i)}$, we can just reverse t and perform the same operations as we did for ${f(i)}$.\nNow we can just loop through each position and calculate the answer.\nMy code:\n#include\u0026lt;bits/stdc++.h\u0026gt;#define ll long long #define M 200007 #define mod 1000000007 using namespace std; const int kinds = 256;///maximum ASCII value of any character of the string int nn; char str[M]; int K, buc[M], r[M], sa[M], X[M], Y[M], high[M]; bool cmp(int *r, int a, int b, int x) { return (r[a] == r[b] \u0026amp;\u0026amp; r[a + x] == r[b + x]); } vector\u0026lt;int\u0026gt;saa; int lcp[M]; string t, s; int n, m; void suffix_array_DA(int n, int m) { int *x = X, *y = Y, i, j, k = 0, l; memset(buc, 0, sizeof(buc)); for (i = 0; i \u0026lt; n; i++) buc[ x[i] = str[i] ]++; for (i = 1; i \u0026lt; m; i++) buc[i] += buc[i - 1]; for (i = n - 1; i \u0026gt;= 0; i--) sa[--buc[x[i]]] = i; for (l = 1, j = 1; j \u0026lt; n; m = j, l \u0026lt;\u0026lt;= 1) { j = 0; for (i = n - l; i \u0026lt; n; i++) y[j++] = i; for (i = 0; i \u0026lt; n; i++) if (sa[i] \u0026gt;= l) y[j++] = sa[i] - l; for (i = 0; i \u0026lt; m; i++) buc[i] = 0; for (i = 0; i \u0026lt; n; i++) buc[ x[y[i]] ]++; for (i = 1; i \u0026lt; m; i++) buc[i] += buc[i - 1]; for (i = n - 1; i \u0026gt;= 0; i--) sa[ --buc[ x[y[i]] ]] = y[i]; for (swap(x, y), x[sa[0]] = 0, i = 1, j = 1; i \u0026lt; n; i++) x[sa[i]] = cmp(y, sa[i - 1], sa[i], l) ? j - 1 : j++; } for (i = 1; i \u0026lt; n; i++) r[sa[i]] = i; for (i = 0; i \u0026lt; n - 1; high[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; str[i + k] == str[j + k]; k++); } void suffix_array_construction(string s) { int n = s.size(); for (int i = 0; i \u0026lt; n; i++) str[i] = s[i]; str[n] = \u0026#39;\\0\u0026#39;; suffix_array_DA(n + 1, kinds); for (int i = 1; i \u0026lt;= n; i++) saa.push_back(sa[i]); } void lcp_construction(string const\u0026amp; s, vector\u0026lt;int\u0026gt; const\u0026amp; p) { int n = s.size(); vector\u0026lt;int\u0026gt; rank(n, 0); for (int i = 0; i \u0026lt; n; i++) rank[p[i]] = i; int k = 0; for (int i = 0; i \u0026lt; n; i++) { if (rank[i] == n - 1) { k = 0; continue; } int j = p[rank[i] + 1]; while (i + k \u0026lt; n \u0026amp;\u0026amp; j + k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) k++; lcp[rank[i]] = k; if (k) k--; } } bool greaterEqual(int sp, int n, const string \u0026amp;ps) { int spl = n - sp, sps = ps.size(), o = min(spl, sps); for (int i = 0; i \u0026lt; o; i++) { if (t[sp + i] \u0026gt; ps[i]) return 1; else if (t[sp + i] \u0026lt; ps[i]) return 0; } return spl \u0026gt;= sps; } bool greaterByVal(int sp, int n, const string \u0026amp;ps) { int spl = n - sp, sps = ps.size(), o = min(spl, sps); for (int i = 0; i \u0026lt; o; i++) { if (t[sp + i] \u0026gt; ps[i]) return 1; else if (t[sp + i] \u0026lt; ps[i]) return 0; } return 0; } pair\u0026lt;int, int\u0026gt; rangeString(int n, const string \u0026amp;ps) { // returns [a,b) , not [a,b]  int lo = 0, hi = n - 1, l = n, r = n; while (lo \u0026lt;= hi) { auto mid = (lo + hi) \u0026gt;\u0026gt; 1; if (greaterEqual(saa[mid], n, ps)) l = mid, hi = mid - 1; else lo = mid + 1; } lo = l, hi = n - 1; while (lo \u0026lt;= hi) { auto mid = (lo + hi) \u0026gt;\u0026gt; 1; if (greaterByVal(saa[mid], n, ps)) r = mid, hi = mid - 1; else lo = mid + 1; } return {l, r}; } bool match(int mid) { int cnt = 0; for ( int j = 0, k = mid; j \u0026lt; m and k \u0026lt; n; j++, k++ ) { if ( t[k] == s[j] ) cnt++; else break; } if (cnt \u0026gt;= m) return 1; return 0; } ll st[M], en[M]; ll shuru[M], shesh[M]; string ss[M]; int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin \u0026gt;\u0026gt; t; n = t.size(); suffix_array_construction(t); lcp_construction(t, saa); nn = saa.size(); int q; cin\u0026gt;\u0026gt;q; for ( int i = 0; i \u0026lt; q; i++ ) { cin \u0026gt;\u0026gt; ss[i]; pair\u0026lt;int,int\u0026gt;strRange= rangeString(n,ss[i]); st[strRange.first]++; st[strRange.second]--; // [a,b)  } for( int i=1;i\u0026lt;n;i++ ) st[i]+= st[i-1]; for( int i=0;i\u0026lt;n;i++ ) shuru[saa[i]]= st[i]; saa.clear(); reverse(t.begin(), t.end()); suffix_array_construction(t); lcp_construction(t, saa); for ( int i = 0; i \u0026lt; q; i++ ) { reverse( ss[i].begin(), ss[i].end() ); pair\u0026lt;int,int\u0026gt;strRange= rangeString(n,ss[i]); en[strRange.first]++; en[strRange.second]--; // [a,b)  } for( int i=1;i\u0026lt;n;i++ ) en[i]+= en[i-1]; for( int i=0;i\u0026lt;n;i++ ) shesh[n-saa[i]-1]= en[i]; ll ans= 0; for( int i=1;i\u0026lt;n;i++ ) ans+= ( shuru[i]*shesh[i-1] ); cout\u0026lt;\u0026lt; ans ; } ","date":"2021-07-21T00:25:58+06:00","image":"https://aritra741.github.io/pexels-fiona-art-5186869.jpg","permalink":"https://aritra741.github.io/p/string-series-part-1/","title":"String series: Part 1"}]